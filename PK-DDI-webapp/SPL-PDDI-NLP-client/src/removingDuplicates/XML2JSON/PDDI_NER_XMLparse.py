## PDDI_NER_XMLparse.py
#
# An XML parser for the XML generated by the PK DDI NER program (same
# as Bioportal Annotator output). This extracts the annotated concepts
# with their location in the corresponding text and then writes the
# data to JSON. 

# Author: Richard D Boyce and Peter Randall
#
# 
## This library is free software; you can redistribute it and/or
## modify it under the terms of the GNU Library General Public
## License as published by the Free Software Foundation; either
## version 2 of the License, or (at your option) any later version.

## This library is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## Library General Public License for more details.

## You should have received a copy of the GNU Library General Public
## License along with this library; if not, write to the
## Free Software Foundation, Inc., 59 Temple Place - Suite 330,
## Boston, MA 02111-1307, USA.


from lxml import etree
import itertools
import json
import sys
import os.path


class annotation:
	fullId = None
	preferredName = None
	fro = None
	to = None
	semTypes = []

	def __init__(self, name, fullId, to, fro, semTypes):
		self.semTypes = semTypes
		self.to = to
		self.fro = fro
		self.preferredName = name
		self.fullId = fullId

	def __str__(self):
		return 'Preferred Name: ' + self.preferredName +  '\nFull ID: ' + self.fullId + '\nFrom ' + self.fro + ' to ' + self.to + '\nSemTypes: %s' % self.semTypes +'\n'
	
	def toDict(self):
		result = {'semTypes': self.semTypes, 'to' : self.to, 'fro' : self.fro, 'preferredName' : self.preferredName, 'fullId' : self.fullId }
		return result
		 
def findAnnots():
	annots = []
	roots = tree.xpath('//annotatorResultBean')
	for root in roots:
		fD = root.xpath('//fullId')
		nm = root.xpath('//preferredName')
		to = root.xpath('//to')
		fro = root.xpath('//from')
		sem = tree.xpath('/success/data/annotatorResultBean/annotations/annotationBean/context/term/concept/semanticTypes')
		for i, n, t, f, s in itertools.izip(nm,fD,to,fro,sem):
			smstr = []
			for each in s:
				k = each[1].text.strip()
				smstr.append(k)
			x = annotation(i.text.strip(), n.text.strip(), t.text.strip(), f.text.strip(), smstr)
			annots.append(x)
	return annots
